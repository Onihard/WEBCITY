<!-- Модальное окно и JS для профиля/DM/Mail удалены, переходы будут обычными -->
{% extends "base.html" %}
{% block title %}Комната {{ room_name }}{% endblock %}

{% block content %}
<div class="row g-3">
  <div class="col-lg-9">
    <div class="d-flex align-items-center mb-3 gap-2">
      <h2 class="mb-0"><i class="bi bi-door-open"></i> {{ room_name }}</h2>
      <form action="{{ url_for('leave_room') }}" method="post" class="ms-auto">
        <button class="btn btn-outline-secondary btn-sm"><i class="bi bi-box-arrow-left"></i> Выйти</button>
      </form>
    </div>

    <div id="messages" class="border rounded-3 p-3 bg-body-secondary shadow-sm" style="height: 420px; overflow-y: auto;">
      <!-- Сообщения будут подгружаться сюда -->
    </div>

    <form class="mt-3 d-flex gap-2" onsubmit="event.preventDefault(); sendMessage();">
      <input id="messageInput" placeholder="Написать сообщение..." class="form-control" autocomplete="off" required maxlength="500">
      <button id="sendBtn" class="btn btn-success"><i class="bi bi-send"></i></button>
    </form>

    <div class="mt-2">
      <small class="text-muted">Вы: {{ nickname or "Гость (войдите для отправки)" }}</small>
    </div>
  </div>
  <div class="col-lg-3">
    <div class="card">
      <div class="card-header d-flex justify-content-between align-items-center">
        <span>Участники</span>
        <span class="badge bg-secondary" id="membersCount">0</span>
      </div>
      <ul class="list-group list-group-flush" id="membersList" style="max-height: 480px; overflow:auto;"></ul>
    </div>
  </div>
</div>
{% endblock %}

{% block scripts %}
<script>
const roomName = {{ room_name|tojson }};
const messagesDiv = document.getElementById('messages');
const messageInput = document.getElementById('messageInput');
const sendBtn = document.getElementById('sendBtn');

let lastMessageId = null;      // id последнего (самого нового) сообщения в списке
let oldestMessageId = null;    // id самого старого сообщения в списке
let autoScroll = true;         // автоскролл к низу, если пользователь у низа
const BOTTOM_THRESHOLD = 40;   // px от низа, чтобы считать, что пользователь внизу
const TOP_THRESHOLD = 40;      // px от верха, чтобы грузить старые
const MAX_MESSAGES = 300;      // ограничение на количество DOM-узлов

function gravatarUrl(nick) {
  // Простейший md5 (только для демонстрации, лучше делать на сервере)
  function md5(s){return CryptoJS.MD5(s.trim().toLowerCase()).toString();}
  return 'https://www.gravatar.com/avatar/' + md5(nick) + '?d=identicon';
}
function renderMessage(m) {
  const div = document.createElement('div');
  div.className = 'd-flex align-items-start gap-2 mb-2 fadein';
  const avatar = document.createElement('img');
  avatar.src = gravatarUrl(m.nickname);
  avatar.className = 'rounded-circle border shadow-sm';
  avatar.style.width = '36px';
  avatar.style.height = '36px';
  avatar.alt = 'avatar';
  div.appendChild(avatar);
    const body = document.createElement('div');
    body.className = 'flex-grow-1';
    const head = document.createElement('div');
    head.className = 'd-flex align-items-center gap-2';
    const bold = document.createElement('strong');
    bold.textContent = m.nickname;
    head.appendChild(bold);
    const time = document.createElement('small');
    time.className = 'text-muted';
    time.textContent = m.time;
    head.appendChild(time);
    // Кнопка удаления для своих сообщений
    if (window.currentUser && m.nickname === window.currentUser) {
      const delBtn = document.createElement('button');
      delBtn.className = 'btn btn-sm btn-outline-danger ms-2';
      delBtn.innerHTML = '<i class="bi bi-trash"></i>';
      delBtn.title = 'Удалить';
      delBtn.onclick = function() {
        fetch('/delete_message/' + m.id, {method: 'POST'})
          .then(r => r.json())
          .then(res => { if (res.ok) div.remove(); });
      };
      head.appendChild(delBtn);
    }
    body.appendChild(head);
    const text = document.createElement('div');
    text.textContent = m.text;
    body.appendChild(text);
    div.appendChild(body);
    return div;
}
window.currentUser = {{ nickname|tojson }};

function atBottom() {
  const delta = messagesDiv.scrollHeight - messagesDiv.clientHeight - messagesDiv.scrollTop;
  return delta <= BOTTOM_THRESHOLD;
}

function scrollToBottom() {
  messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

function trimIfNeeded() {
  // Поддерживаем ограничение числа сообщений, удаляя самые старые сверху
  while (messagesDiv.children.length > MAX_MESSAGES) {
    messagesDiv.removeChild(messagesDiv.firstChild);
  }
}

// Начальная загрузка последних сообщений и прокрутка вниз
async function initialLoad() {
  try {
    const res = await fetch(`/get_messages/${encodeURIComponent(roomName)}`);
    if (!res.ok) return;
    const data = await res.json();
    if (!data.length) return;
    data.forEach(m => {
      messagesDiv.appendChild(renderMessage(m));
      oldestMessageId = oldestMessageId == null ? m.id : Math.min(oldestMessageId, m.id);
      lastMessageId = m.id; // в конце будет id самого нового
    });
    scrollToBottom();
  } catch(e) {
    console.error('Ошибка при начальной загрузке сообщений', e);
  }
}

// Подгрузка новых сообщений (после lastMessageId)
async function loadNewMessages() {
  try {
    let url = `/get_messages/${encodeURIComponent(roomName)}`;
    if (lastMessageId) url += `?after_id=${lastMessageId}`;
    const wasAtBottom = atBottom();
    const res = await fetch(url);
    if (!res.ok) return;
    const data = await res.json();
    if (!data.length) return;

    data.forEach(m => {
      messagesDiv.appendChild(renderMessage(m));
      lastMessageId = m.id;
      if (oldestMessageId == null) oldestMessageId = m.id;
    });

    trimIfNeeded();

    // Скроллим вниз только если пользователь был у низа
    autoScroll = wasAtBottom || autoScroll;
    if (autoScroll) scrollToBottom();
  } catch(e) {
    console.error('Ошибка при обновлении сообщений', e);
  }
}

// Подгрузка старых сообщений (до oldestMessageId), с сохранением позиции скролла
async function loadOlderMessages() {
  if (!oldestMessageId) return;
  try {
    const prevScrollHeight = messagesDiv.scrollHeight;
    const res = await fetch(`/get_messages/${encodeURIComponent(roomName)}?before_id=${oldestMessageId}`);
    if (!res.ok) return;
    const data = await res.json();
    if (!data.length) return; // больше старых нет

    // prepend: добавляем в начало, сохраняя видимую позицию
    const fragment = document.createDocumentFragment();
    data.forEach(m => {
      fragment.appendChild(renderMessage(m));
      oldestMessageId = Math.min(oldestMessageId, m.id);
      if (lastMessageId == null) lastMessageId = m.id;
    });
    messagesDiv.insertBefore(fragment, messagesDiv.firstChild);

    // Корректируем scrollTop, чтобы контент не "прыгнул"
    const newScrollHeight = messagesDiv.scrollHeight;
    messagesDiv.scrollTop = newScrollHeight - prevScrollHeight + messagesDiv.scrollTop;

    trimIfNeeded();
  } catch(e) {
    console.error('Ошибка при подгрузке старых сообщений', e);
  }
}

// Отправка сообщения через fetch (без перезагрузки)
async function sendMessage() {
  const text = messageInput.value.trim();
  if (!text) return;
  try {
    const formData = new FormData();
    formData.append('message', text);
    const res = await fetch(`/send_message/${encodeURIComponent(roomName)}`, {
      method: 'POST',
      body: formData
    });
    if (res.ok) {
      messageInput.value = '';
      autoScroll = true; // после отправки логично удерживать низ
      loadNewMessages();
    }
  } catch(e) {
    console.error('Ошибка при отправке сообщения', e);
  }
}

let messagesLoaded = false;
function safeInit() {
  if (messagesLoaded) return;
  messagesLoaded = true;
  initialLoad();
  setInterval(loadNewMessages, 2000);
}

sendBtn.addEventListener('click', sendMessage);
messageInput.addEventListener('keydown', e => {
  if (e.key === 'Enter') {
    e.preventDefault();
    sendMessage();
  }
});

messagesDiv.addEventListener('scroll', () => {
  autoScroll = atBottom();
  if (messagesDiv.scrollTop <= TOP_THRESHOLD) {
    loadOlderMessages();
  }
});

window.addEventListener('DOMContentLoaded', safeInit);

// Подключаем bootstrap icons и crypto-js для md5
const bi = document.createElement('link');
bi.rel = 'stylesheet';
bi.href = 'https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css';
document.head.appendChild(bi);
const cs = document.createElement('script');
cs.src = 'https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js';
document.head.appendChild(cs);

// ---- Участники комнаты ----
const membersList = document.getElementById('membersList');
const membersCount = document.getElementById('membersCount');

async function updateMembers() {
  try {
    const res = await fetch(`/room_members/${encodeURIComponent(roomName)}`);
    if (!res.ok) return;
    const data = await res.json();
    membersList.innerHTML = '';
    data.forEach(u => {
      const li = document.createElement('li');
      li.className = 'list-group-item d-flex align-items-center gap-2';
      // онлайн-статус
      const dot = document.createElement('span');
      dot.style.width = '10px';
      dot.style.height = '10px';
      dot.style.borderRadius = '50%';
      dot.style.display = 'inline-block';
      dot.style.background = u.online ? '#28a745' : '#dc3545';
      dot.title = u.online ? 'В сети' : 'Не в сети';
      li.appendChild(dot);
      // ник (ссылка на профиль)
      const link = document.createElement('a');
      link.href = '#';
      link.textContent = u.nickname;
      link.className = 'ms-2 text-decoration-none';
      link.onclick = function(e) {
        e.preventDefault();
        openModal('Профиль: ' + u.nickname, '/profile_modal/' + encodeURIComponent(u.nickname));
      };
      li.appendChild(link);
      membersList.appendChild(li);
    });
    membersCount.textContent = data.length;
    // Обновляем счетчик участников в заголовке комнаты (если есть)
    const roomHeader = document.querySelector('.room-header-count');
    if (roomHeader) roomHeader.textContent = data.length;
  } catch(e) {
    // noop
  }
}
setInterval(updateMembers, 3000);
updateMembers();
</script>
{% endblock %}
